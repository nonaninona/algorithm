# 생각의 흐름
1. 우선 계산 방식을 이해하기. 예제를 가지고 어떻게 곱셈이 이뤄지는 지 확인함
2. 완전 탐색일 때 복잡도를 계산해봄. combination(500, 2) x combination(499, 2) x ... 로 확인
3. 문제에서 행렬의 순서는 고정이라는 이야기를 이제 확인. 그렇다면 부분문제로 쪼갤 수 있을 것 같다고 생각
4. start, end로 이루어진 2차원 배열을 구성할 수 있다고 생각함. 대충 생각해보니 0에서 2까지의 배열의 곱의 최소를 (0,2)라고 하면, 0(1,2) 또는 (0,1)2 중에 최소를 구하는 방식으로 진행 가능하다고 생각함.
5. 그러나 그 범위가 (0,3)과 같이 커지면 (0,1)(2,3)과 같은 형태도 띌 수 있음. 따라서 모든 조합을 찾아서 최솟값을 찾아야 함. 다만, 그 조합에서 값을 구할 때 이전 값을 활용 가능.
6. 이전 값 활용 방식을 보면, 범위를 늘려나가면서 구해야 이전 값을 활용할 수 있음. 그림으로 따지자면, 처음엔 가장 큰 대각선, 그 다음에는 한칸 위의 대각선 이런 형태
7. 시간복잡도는, 범위 1~N(대각선에 있는 요소 1~N-범위(범위에 대한 조합 1~범위))라서 대략 N^3??이 됨.
8. 사실 잘 모르겠음.. GPT에 물어보니 시그마의 형태로 풀어해치는 방식으로 구함.<br>
   시그마(범위 r=1~N)시그마(요소 start=1~N-r)시그마(조합 t=1~r) 1<br>
   <img width="326" alt="image" src="https://github.com/user-attachments/assets/384f39aa-4169-4c0b-aeb4-64401cb24ec3"><br>
   이를 풀면, 시그마(조합 t=1~r) 1 = r (반복횟수가 r번이기 때문에) => 시그마(요소 start=1~N-r) r<br>
   시그마(요소 start=1~N-r) r = r(N-r) (반복횟수가 N-r이기 때문에) => 시그마(범위 r=1~N) r(N-r)<br>
   시그마(범위 r=1~N) r(N-r) = N * 시그마(범위 r=1~N) r - 시그마(범위r=1~N) r^2 => N * (N-1)N/2 - (N-1)N(2N-1)/6 => N^3
9. N^3이면 솔직히 애매하긴 함. 실제로 코드 작성 후 제출하니 시간 초과가 떴음.
10. 그런데 DP로 푸는 방식은 이것 말고 어떻게 풀어야할 지 몰라서 50분 헤매다가 pypy3로 제출하니 통과함;;

# 다른 사람 답 참고
근데 그리디로 풀 수도 있나봄?? 어케하는 지는 몰루

   
