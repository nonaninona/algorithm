# 생각의 흐름
1. 일단 경우의 수가 4의 10승이라서 완탐 돌려도 널널함(보드 전체 탐색해도)
2. 음.. 이거 구슬 옮기는 거 구현이 에바네
3. ... 시도하다가 결국 답 봄
4. 아 최단 거리 출력이네; 그냥 1 아니면 -1 출력인줄..
5. 그러면 dfs가 아니라 무조건 bfs임
6. 전체 보드 상태 말고 구슬 2개의 좌표를 상태로 하면 상태 공간이 다 표현이 됨
7. 상태 간에 전이는 이제 기울임에 의해서 이루어짐
8. 결국 큐에서 꺼낸 상태(구슬 좌표 + 도달 횟수) 에서 전이를 어떻게 구현하냐임
9. 구슬의 이동 방향을 Dy, Dx로 정의하고 while 문으로 각 방향들에 대해서 구슬을 옮기도록 작성
10. dfs로 구현하려고 할 때는 보드 전체를 탐색하면서 구슬을 한 번에 이동시키는(swap 느낌) 방식으로 하려고 했는데, 그냥 구슬에 초점을 맞춰서 한 칸 씩 옮기는 게 구현도 편하고 성능도 좋음
11. 일단 구슬을 이동 시켜놓고 예외 상황(1-벽에 멈춘 경우, 이전으로 돌리기/2-구슬이 겹친 경우 더 많이 이동한 애를 이전으로 돌리기) 처리를 하면 더 구현이 편함

![image](https://github.com/user-attachments/assets/3d94382b-5d02-4b8b-8a85-db66db0a2bd1)

# 배운점
- 문제를 꼼꼼하게 차근차근 보자 급하지 않게. 결국 더 돌아가게 됨
- 결국 알고리즘 문제는 상태 공간을 정의하는 것이 중요함. 핵심 정보들에만 집중해보자(사실 구슬의 좌표만 가지고 뭘 해보겠다는 생각은 했었음. 그런데 구슬에 초점을 맞추지 않아서 문제였긴 함)
- Dy, Dx, while 문 조합 잘 기억해두자
- 우선 예외 상황은 고려하지 말고 작성해보는 게 더 쉬운 방향일 수 있음
- 종료 조건 표현 시에도 너무 많은 걸 고려하려고 하지 말고 일단 대충 표현해두고 전이 방식 구현할 때 맞춰가도 좋음
