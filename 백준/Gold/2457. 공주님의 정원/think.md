![Ongoing-386](https://github.com/user-attachments/assets/7b43a037-8203-47f5-977b-86ab0b454881)# 생각의 흐름
1. 음.. 일단은 날짜를 일 단위로 환산해서 풀면 쉬울 것 같다는 생각을 함
2. 꽃을 선택할지 말지 결정하는 게 부분문제려나??
3. 그러면 중요한 건 결정하는 꽃의 순서겠군..
4. 일단 예제를 보면서 파악해보자..
5. 1 1 6 30은 1 1 5 31의 상위호환이곘군..
6. 6 10 12 10은 11 30을 넘는 유일한 친구라서 무조건 포함해야겠네..
7. 10개짜리 예제도 봐보자
8. 음 일단 11 30을 넘는 애는 2개니까 이 둘 중 하나는 들어가야겠네...
9. 어라? 그러면 피는 시간이 빠른 걸 넣는 게 좋은 거네
10. 그리고 가장 빠른 피는 시간이 또 다음 문제의 11 30 역할을 하게 됨
11. 아 그러면 종료 기준보다 늦게 지는 꽃들 중 가장 피는 시간이 빠른 꽃을 선택하는 것을 반복하고 + 다음 꽃을 선택할 때 사용하는 종료 기준은 이번에 선택한 꽃의 피는 시간이네
12. 그러면 부분문제는 종료 기준을 가지고 나누게 되는 거고, 탐욕 선택 속성은 가장 빨리 지는 애를 고르는 거네
13. 닫힌구간 반열린구간 신경써야겠네... 부등호에 등호를 붙이냐 마냐임..
14. 그런데 생각해보니까 지금처럼 뒤에서부터 보지 말고 앞에서부터 봐도 될 듯
15. 음.. 그런데 생각해보니 11 30을 넘는 애들은 딱히 판단할게 없네. 어차피 뭘 선택하던 그냥 종료임 => 마지막 부분문제 판단(=종료조건)
16. 1차 제출 -> 틀렸습니다
17. 답이 없을 때 처리를 안해줌 => 반복문에서 종료조건에 진입하냐 안하냐로 구분
18. 2차 제출 -> 시간 초과
19. 어디서 나는 거지... 어차피 i-=1인 부분이 문제일 거고... 답이 없는 경우가 문제인가? => ㅇㅇ 맞았음 most_late 값을 조정하지 않아서 생기는 문제이긴 한데 그냥 더 쉽게 해결함

![Ongoing-384](https://github.com/user-attachments/assets/d7069f43-8474-4e04-b5ed-6d94bc6ee89b)
![Ongoing-385](https://github.com/user-attachments/assets/00102533-5d4e-4d05-8f83-b9cbbe1dde29)
![Ongoing-386](https://github.com/user-attachments/assets/c2cb8aa9-0b18-4e2b-b026-f5f8724221fe)

# 배운점
- 일로 단위 환산하기([그냥 4자리 문자열로 써도 된다고는 함](https://maivve.tistory.com/324#:~:text=MMDD%20%EB%A5%BC%20%EA%B7%B8%EB%8C%80%EB%A1%9C%204%EC%9E%90%EB%A6%AC%EC%9D%98%20%EC%88%AB%EC%9E%90%EB%A1%9C%20%ED%99%9C%EC%9A%A9%ED%95%98%EB%A9%B4%20%EB%90%A9%EB%8B%88%EB%8B%A4.))가 자주 나옴
- 꽃을 선택하는 것의 반복이 부분문제가 됨. 역시 부분문제를 쪼갠다는 발상으로 이어지는 것이 중요
- 부분문제를 나누는 기준이 동적으로 변동될 수 있음
- 닫힌 구간, 반열린 구간에 대한 개념을 알고 있는 것이 off by one error 처리에 도움이 됨
- 답이 없는 경우에 대한 예외처리 및 시간복잡도 파악은 오답을 피하는데 필수적임
