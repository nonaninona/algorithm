# 생각의 흐름
1. 일단 나이브하게 모든 1을 하나씩 없애고 + bfs 해버리기 => 시간 복잡도 대략 1의 개수 x 5,000,000 나옴 ㅋㅋ
2. !검색 찬스! 다익스트라는 아니다(엣지에 가중치 있을 때 이야기임) 순수 bfs인 듯.
3. 1을 다 선택해도 할 수 없다면... 뭘 기준으로 고르지?
4. 그냥 번뜩인 아이디어 : 어 그러면 값이 1인 노드로 이동했을 때 1번의 기회를 주면??? 원래 (y, x, d)로 하던 거에 c라는 애를 붙여주면??
5. 근데 그렇게 하면 visited가 이상할 것 같음. 예를 들어 중간 지점인 N까지 가는 A루트와 B루트가 있을 때,<br>
A는 초반에 부수고 시작하면 N까지 금방 가고, B는 N까지 가는데 오래걸리면 B는 중간에 cut off 당함.<br>
근데 N 이후에 최종지점인 F까지 가는 길에서, 하나만 부수면 금방 가는데 못 부수는 경우 개 돌아가야 하면??<br>
그러면 B를 가지치기 안했으면 최단거리가 나왔을 텐데 bfs로 최단거리는 구하는 과정이면 무조건 가지쳐짐.
6. 또 번뜩임 왜 이 생각이 들었는지는 모르겠는데 아무튼 아무 생각이나 해보려고 노력했음 최대한 아이디어 선에서 그치지 않고 그려보고 구체화해보는 걸 반복하다보니 나옴 :<br>
그러면 부수는 기회가 있을 때와 없을 때의 visited를 나눌까?
7. 근데 사실 이런다고 답이 나오는 지 검증은 못했고, 시간 복잡도도 못 구함.
8. 근데 아무튼 이대로 짜니까 되긴 했음.
9. 흠 정당성 증명은 대충...<br>
단순히 visited의 상태가 2개면 충분하다는 걸 증명하면 된다고 생각함.<br>
그러면 앞서 제기했던 싹수가 노란 가지를 쳐버리는 경우가 없다는 걸 보이면 됨.<br>
부수기 전의 상태에서는, 이미 숫자가 기록된 경우, 그것보다 빠르게 도달하는 경우가 없는 게 맞음<br>
그리고 하나 부순 상태로 이동했을 때, 이미 숫자가 기록되어 있는 경우, 그것보다 빠르게 도달하는 경우가 없는 게 맞음. 같은 상태이면서 더 빠른 게 있었다는 거니까<br>
결국 여기서 같은 상태이면서도 늦게 도달했다는 것은 그냥 최단거리가 아니라는 거고, 이걸 부쉈냐 안부쉈냐라는 상태 구분에서만 판단하면 되니까 상태도 자연스레 2개만 있으면 됨<br>
10. 시간복잡도는 진짜 모르겠긴 함... 대충 node가 1개 edge가 4개씩 더 생긴다고 가정하면 N = 2,000,000 / E = 8,000,000 => O(N+E) = 10,000,000 천만 정도??

![Ongoing-194](https://github.com/user-attachments/assets/efe413e5-2134-4eb8-b704-14ea37efa0dc)
![Ongoing-195](https://github.com/user-attachments/assets/81eb15e3-4dd9-4f99-8673-7866498f18a1)

# 다른 사람 답 참고
