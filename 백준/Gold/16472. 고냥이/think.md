# 생각의 흐름
- 대충 슬라이딩 윈도우로 구간을 잡아가면 되지 않을까?

# 배운점
- 슬라이딩 윈도우의 구간의 크기를 조절하면서, 특정 개수나 제약 조건을 세는 유형(특히 hash가 아니라 배열)이 은근 많은 듯 하다.
- 추가적인 질문(by gemini)
1. 시간 복잡도 증명: 이 코드에는 for 루프 안에 while 루프가 중첩되어 있습니다. 언뜻 보면 O(문자열 길이^2)처럼 보일 수도 있습니다. 하지만 이 코드의 시간 복잡도는 O(문자열 길이) 입니다. left 포인터와 right 포인터의 어떤 특성 때문에 이것이 선형 시간 복잡도임을 '증명'할 수 있을까요?
<br><br>left가 right보다 클 수 없고, 서로 한쪽 방햐응로만 이동하므로 선형 시간 복잡도일 수 밖에 없음
2. 다른 도구와의 비교 (Systemic Thinking): "어떤 조건 범위 내에서 최댓값을 찾는다"는 문장은 '이분 탐색(Parametric Search)'을 떠올리게 하기도 합니다. 예를 들어, "길이가 K인 문자열 중에서 알파벳 종류가 N개 이하인 것이 존재하는가?"라는 결정 문제로 바꾸는 방식입니다. 이 문제가 '이분 탐색'으로는 풀 수 없거나, 혹은 투 포인터보다 비효율적인 이유는 무엇일까요? 두 알고리즘의 근본적인 차이점은 무엇일까요?
<br><br> 이분탐색으로도 풀 수 있음. 길이를 이동시켜가면서 문자열을 처음부터 끝까지 보면서 해당 길이의 문자열의 알파벳 종류를 세면 됨. 시간복잡도는 길이 * log 길이. 투포인터보다 비효율적인 이유는, 투포인터는 문자열을 한 번만 보지만, 이분 탐색은 매 mid마다 문자열을 봐야하기 때문
3. 문제 조건의 변경: 만약 문제에서 '연속된'이라는 조건이 사라지고, "문자열의 부분 수열(subsequence) 중 최대 N개의 알파벳 종류를 가지는 가장 긴 부분 수열의 길이를 구하라"고 했다면, 현재의 투 포인터 접근법은 여전히 유효할까요? 유효하지 않다면 그 이유는 무엇일까요?
<br><br> 투포인터 접근법은 유효하지 않음. 왜냐하면 left의 의미는 "제외"인데 그게 보장이 안되고, right의 의미인 "포함"도 마찬가지라서.
<br>그러면 부분 수열로 바뀌면 어떻게 푸나 싶었음. 처음에는 DP 느낌으로 접근하려고 했음. 왜냐하면 부분수열만 보면 LIS 생각이 나서;;
<br>그리고 결국 해당 지점까지 알파벳을 무엇을 썼냐를 알아야 하니까 비트마스킹 정도로 가져가려고 했는데 2^26승이면 꽤 큰 수임. 그리고 순서가 중요한 게 아니라서 굳이 bitmasking을 가져갈 필요가 없음.
<br>다시 생각해보면, 그냥 문자를 고른 다음에 문자열에 그 문자가 얼마나 있나 세면 됨. 26Cn * 길이 = 대략 1억 3천 정도.
