# 생각의 흐름
1. operation이 1,000,000개임<br>
시간 복잡도 대충 계산해보면 삽입 500,000번 한 뒤에 최대 최소 pop만 한다고 가정했을 때<br>
n = 500,000고 n번의 최대 최소 찾기 -> n^2 = 250,000,000,000 => 무조건 최대 최솟값 구하는 게 log n이긴 해야 함
2. 음... 그럼 저 이중 우선순위 큐라는 걸 진짜 구현을 해야겠네<br>
최소큐를 쓰면서, 최대값은 그냥 손수 계산하면?? 평균적으로는 log n과 n 사이겠지만 최대 값만 pop 하면 말짱 도루묵이군...<br>
어 그럼 그냥 최소큐에도 넣고 최대큐에도 넣으면 되는 거 아닌가? 그리고 한쪽에서 pop 되면 disable을 하는 거지
3. 나 혹시 천재?

근데 큐 자체를 이번에 한 번 정리할 필요를 느꼈음<br>
[정리 잘 되어 있는 블로그](https://velog.io/@gnwjd309/data-structure-heap)<br>
힙 = 완전 이진 트리 = 데이터 추가 시 왼쪽이 먼저 채워<br>
BST는 크기 관계가 왼쪽 자식 < 부모 < 오른쪽 자식으로 되어있는데<br>
힙은 자식 크기 < 부모 크기만 지키면 됨. 왼쪽 자식 오른쪽 자식 간의 크기 차이는 상관 없음<br>
삽입 시 완전 이진 트리를 만족할 수 있는 그 위치(가장 마지막 위치)에 넣음 그리고 부모를 쭉 타고 가면서 내가 부모보다 작으면(최소힙) 자리를 바꿈. 내가 더 크면 멈춤<br>
삭제 시 루트를 삭제한 뒤, 가장 마지막 위치에 있는 애를 루트에 옮김. 밑의 자식들하고 주욱 비교하면서 내가 더 크면(최소힙) 자리를 바꿈. 내가 더 작으면 멈춤<br>
완전 이진 트리라는 개념과 삽입, 삭제 시 가장 마지막 위치에 해당하는 부분을 생각해보면 배열로 구현하기 쉽다는 것을 알 수 있음(자식인덱스 = 부모 인덱스 * 2, 부모 인덱스 * 2 + 1)<br>
구현 편하게 하려면 인덱스 1부터 구현하는 게 쉬움

![image](https://github.com/user-attachments/assets/4e164c11-9f8c-44eb-ae1e-70dc06b0dc32)

# 다른 사람 답 참고
