# 생각의 흐름
1. 그냥 평범한 그래프 탐색 문제라고 생각했음... 그런데... 모든 노드를 다 방문하는 게 목적이 아니고 모든 엣지를 다 활용해야함.
2. 그리고 답을 알파벳 순으로 정렬했을 때 가장 먼저 오는 애로 해야하는데, 문제는 현재 노드에서 단순히 greedy하게 알파벳 순으로 가장 빠른 노드를 탐색하는 방법을 쓸 수 없음.
3. 왜냐하면, 알파벳 순으로 가장 빠른 노드로 이동했다가, 전부 탐색할 수 없을 수도 있기 때문.
4. 그러면... 다 돌아보면서 답 후보를 구하고, 그 후보들을 가지고 정렬을 해야하는 거네?? 아 그러면 저번에 풀어본 백트래킹 느낌??
5. DFS에다가 상태 배열에 체크하고 다음 step dfs 돌린 뒤 돌아와서 다시 상태 배열 체크 해제하는 그 방식으로 하면 되겠네
6. 근데 시간복잡도 어떡함?? 어떻게 구하는 지 모르겠음. 일단은 복잡도는 충족한다고 가정한다고 풀어보자.
7. 우선 노드가 아니라 엣지에 방문 여부를 추가 해야함.
8. 그리고 방문순서까지 알아야 하므로 방문 여부를 True/False가 아니라 숫자로 표현. 초기값은 -1
9. 풀긴 했다... 그런데 시간복잡도는??
10. 일반적인 dfs 보다는 오래 걸릴텐데... 아 단순히 엣지 개수에 비례할 듯??

![Ongoing-211](https://github.com/user-attachments/assets/a2a83402-6d57-4f4e-a09b-d5fe04df2b7c)

[백준 1987 알파벳 문제](https://github.com/nonaninona/algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/1987.%E2%80%85%EC%95%8C%ED%8C%8C%EB%B2%B3/think.md)와 유사함

# 다른 사람 답 참고
